rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim = 80000#
numPatterns = 35#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
numSim=35#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
r=seq(0,100,length=1000)#
curves=list(numSim)#
for (i in 1:numSim) {#
   check=findDist(Sblock[[i]],S[[i]])#
   nPts = dim(check)[1]#
   curves[[i]] = numeric(100)#
   for (j in 1:100) {#
      curves[[i]][j] = (sum(check<=r[j])-1)/nPts#
   }#
}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
simCurves=do.call(rbind,curves)#
ordCurves=apply(simCurves,2,sort)#
plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
lines(r,ordCurves[numSim,])#
#
act = findDist(X,allX)#
nPts = dim(act)[1]#
actCurve = numeric(100)#
for (j in 1:100) {#
  actCurve[j] = (sum(check<=r[j])-1)/nPts#
}#
lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
#
numSim=35#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
pKout=K3est(P)#
pGout=G3est(P)#
pFout=F3est(P)#
pPout=pcf3est(P)#
#
simK=list(numSim)#
simG=list(numSim)#
simF=list(numSim)#
simP=list(numSim)#
curvesK=list(numSim)#
curvesG=list(numSim)#
curvesF=list(numSim)#
curvesP=list(numSim)#
for (i in 1:numSim) {#
   simK[[i]]=K3est(sP[[i]])#
   simG[[i]]=G3est(sP[[i]])#
   simF[[i]]=F3est(sP[[i]])#
   simP[[i]]=pcf3est(sP[[i]])#
   curvesK[[i]]=simK[[i]]$iso#
   curvesG[[i]]=simG[[i]]$km#
   curvesF[[i]]=simF[[i]]$km#
   curvesP[[i]]=simP[[i]]$iso#
}#
#
layout20x(2,2)#
#
##do envelopes#
simCurves=do.call(rbind,curvesK)#
ordCurvesK=apply(simCurves,2,sort)#
simCurves=do.call(rbind,curvesG)#
ordCurvesG=apply(simCurves,2,sort)#
simCurves=do.call(rbind,curvesF)#
ordCurvesF=apply(simCurves,2,sort)#
simCurves=do.call(rbind,curvesP)#
ordCurvesP=apply(simCurves,2,sort)#
plot(ordCurvesK[1,],type="l",main="Envelope for K Function")#
lines(ordCurvesK[numSim,])#
lines(pKout$iso,col="red")#
plot(ordCurvesG[1,],type="l",main="Envelope for G Function")#
lines(ordCurvesG[numSim,])#
lines(pGout$km,col="red")#
plot(ordCurvesF[1,],type="l",main="Envelope for F Function")#
lines(ordCurvesF[numSim,])#
lines(pFout$km,col="red")#
plot(ordCurvesP[1,],type="l",main="Envelope for pcf Function")#
lines(ordCurvesP[numSim,])#
lines(pPout$iso,col="red")
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/SR_width_7/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/SR_width_7/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/SR_width_7/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim = 80000#
numPatterns = 35#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
numSim=55#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
r=seq(0,100,length=100)#
curves=list(numSim)#
for (i in 1:numSim) {#
   check=findDist(Sblock[[i]],S[[i]])#
   nPts = dim(check)[1]#
   curves[[i]] = numeric(100)#
   for (j in 1:100) {#
      curves[[i]][j] = (sum(check<=r[j])-1)/nPts#
   }#
}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
simCurves=do.call(rbind,curves)#
ordCurves=apply(simCurves,2,sort)#
plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
lines(r,ordCurves[numSim,])#
#
act = findDist(X,allX)#
nPts = dim(act)[1]#
actCurve = numeric(100)#
for (j in 1:100) {#
  actCurve[j] = (sum(check<=r[j])-1)/nPts#
}#
lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
#
numSim=55#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
pKout=K3est(P)#
pGout=G3est(P)#
pFout=F3est(P)#
pPout=pcf3est(P)#
#
simK=list(numSim)#
simG=list(numSim)#
simF=list(numSim)#
simP=list(numSim)#
curvesK=list(numSim)#
curvesG=list(numSim)#
curvesF=list(numSim)#
curvesP=list(numSim)#
for (i in 1:numSim) {#
   simK[[i]]=K3est(sP[[i]])#
   simG[[i]]=G3est(sP[[i]])#
   simF[[i]]=F3est(sP[[i]])#
   simP[[i]]=pcf3est(sP[[i]])#
   curvesK[[i]]=simK[[i]]$iso#
   curvesG[[i]]=simG[[i]]$km#
   curvesF[[i]]=simF[[i]]$km#
   curvesP[[i]]=simP[[i]]$iso#
}#
#
layout20x(2,2)#
#
##do envelopes#
simCurves=do.call(rbind,curvesK)#
ordCurvesK=apply(simCurves,2,sort)#
simCurves=do.call(rbind,curvesG)#
ordCurvesG=apply(simCurves,2,sort)#
simCurves=do.call(rbind,curvesF)#
ordCurvesF=apply(simCurves,2,sort)#
simCurves=do.call(rbind,curvesP)#
ordCurvesP=apply(simCurves,2,sort)#
plot(ordCurvesK[1,],type="l",main="Envelope for K Function")#
lines(ordCurvesK[numSim,])#
lines(pKout$iso,col="red")#
plot(ordCurvesG[1,],type="l",main="Envelope for G Function")#
lines(ordCurvesG[numSim,])#
lines(pGout$km,col="red")#
plot(ordCurvesF[1,],type="l",main="Envelope for F Function")#
lines(ordCurvesF[numSim,])#
lines(pFout$km,col="red")#
plot(ordCurvesP[1,],type="l",main="Envelope for pcf Function")#
lines(ordCurvesP[numSim,])#
lines(pPout$iso,col="red")
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim = 80000#
numPatterns = 35#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
numSim=55#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
r=seq(0,100,length=100)#
curves=list(numSim)#
for (i in 1:numSim) {#
   check=findDist(Sblock[[i]],S[[i]])#
   nPts = dim(check)[1]#
   curves[[i]] = numeric(100)#
   for (j in 1:100) {#
      curves[[i]][j] = (sum(check<=r[j])-1)/nPts#
   }#
}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
simCurves=do.call(rbind,curves)#
ordCurves=apply(simCurves,2,sort)#
plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
lines(r,ordCurves[numSim,])#
#
act = findDist(X,allX)#
nPts = dim(act)[1]#
actCurve = numeric(100)#
for (j in 1:100) {#
  actCurve[j] = (sum(check<=r[j])-1)/nPts#
}#
lines(r,actCurve,col="red")
dim(actCurve)
size(actCurve)
len(actCurve)
act
actCurve
npts
nPts
actCurve
help(numeric)
r
dim(X)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim = 80000#
numPatterns = 35#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
numSim=55#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
r=seq(0,100,length=100)#
curves=list(numSim)#
for (i in 1:numSim) {#
   check=findDist(Sblock[[i]],S[[i]])#
   nPts = dim(check)[1]#
   curves[[i]] = numeric(100)#
   for (j in 1:100) {#
      curves[[i]][j] = (sum(check<=r[j])-1)/nPts#
   }#
}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
simCurves=do.call(rbind,curves)#
ordCurves=apply(simCurves,2,sort)#
plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
lines(r,ordCurves[numSim,])#
#
act = findDist(X,allX)#
nPts = dim(act)[1]#
actCurve = numeric(100)#
for (j in 1:100) {#
  print sum(check<=r[j])'\n'#
  actCurve[j] = (sum(check<=r[j])-1)/nPts#
}
help(print)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim = 80000#
numPatterns = 35#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
numSim=55#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
r=seq(0,100,length=100)#
curves=list(numSim)#
for (i in 1:numSim) {#
   check=findDist(Sblock[[i]],S[[i]])#
   nPts = dim(check)[1]#
   curves[[i]] = numeric(100)#
   for (j in 1:100) {#
      curves[[i]][j] = (sum(check<=r[j])-1)/nPts#
   }#
}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
simCurves=do.call(rbind,curves)#
ordCurves=apply(simCurves,2,sort)#
plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
lines(r,ordCurves[numSim,])#
#
act = findDist(X,allX)#
nPts = dim(act)[1]#
actCurve = numeric(100)#
for (j in 1:100) {#
  print (sum(check<=r[j])'\n')#
  actCurve[j] = (sum(check<=r[j])-1)/nPts#
}
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim = 80000#
numPatterns = 35#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
numSim=55#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
r=seq(0,100,length=100)#
curves=list(numSim)#
for (i in 1:numSim) {#
   check=findDist(Sblock[[i]],S[[i]])#
   nPts = dim(check)[1]#
   curves[[i]] = numeric(100)#
   for (j in 1:100) {#
      curves[[i]][j] = (sum(check<=r[j])-1)/nPts#
   }#
}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
simCurves=do.call(rbind,curves)#
ordCurves=apply(simCurves,2,sort)#
plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
lines(r,ordCurves[numSim,])#
#
act = findDist(X,allX)#
nPts = dim(act)[1]#
actCurve = numeric(100)#
for (j in 1:100) {#
  print(sum(check<=r[j])'\n')#
  actCurve[j] = (sum(check<=r[j])-1)/nPts#
}
rm(list=ls())
help(rbind)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim = 80000#
numPatterns = 35#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
numSim=55#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
r=seq(0,100,length=100)#
curves=list(numSim)#
for (i in 1:numSim) {#
   check=findDist(Sblock[[i]],S[[i]])#
   nPts = dim(check)[1]#
   curves[[i]] = numeric(100)#
   for (j in 1:100) {#
      curves[[i]][j] = (sum(check<=r[j])-1)/nPts#
   }#
}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
simCurves=do.call(rbind,curves)#
ordCurves=apply(simCurves,2,sort)#
plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
lines(r,ordCurves[numSim,])#
#
act = findDist(X,allX)#
nPts = dim(act)[1]#
actCurve = numeric(100)#
for (j in 1:100) {#
  actCurve[j] = (sum(check<=r[j])-1)/nPts#
}#
lines(r,actCurve,col="red")
actCurves
actCurve
r
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vraj004/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vraj004/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
path3="/Users/vraj004/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/cell2on4/"#
path4="/Users/vraj004/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
#simEnvF <- envelope.pp3(P, fun=F3est, nsim=42, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#simEnvK <- envelope.pp3(P, fun=K3est, nsim=17, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=17, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#library(s20x)#
#layout20x(2,2)#
#plot(simEnvF)#
#plot(simEnvG)#
#plot(simEnvK)#
#plot(simEnvP)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/cell2on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
#simEnvF <- envelope.pp3(P, fun=F3est, nsim=42, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#simEnvK <- envelope.pp3(P, fun=K3est, nsim=17, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=17, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#library(s20x)#
#layout20x(2,2)#
#plot(simEnvF)#
#plot(simEnvG)#
#plot(simEnvK)#
#plot(simEnvP)
plot(simEnvG)
simEnvF <- envelope.pp3(P, fun=F3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))
plot(simEnvF)
simEnvK <- envelope.pp3(P, fun=K3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))
plot(simEnvK)
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))
plot(simEnvP)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/SR_width_6/cell1on2/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=55#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
#simEnvF <- envelope.pp3(P, fun=F3est, nsim=42, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=25, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#simEnvK <- envelope.pp3(P, fun=K3est, nsim=17, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=17, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#library(s20x)#
#layout20x(2,2)#
#plot(simEnvF)#
#plot(simEnvG)#
#plot(simEnvK)#
#plot(simEnvP)
plot(simEnvG)
simEnvF <- envelope.pp3(P, fun=F3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))
simEnvF <- envelope.pp3(P, fun=F3est, nsim=25, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))
plot(simEnvF)
simEnvK <- envelope.pp3(P, fun=K3est, nsim=25, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))
plot(simEnvK)
plot(simEnvF)
plot(simEnvG)
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=25, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/cell2on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)#
dev.off()
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/SR_width_6/cell2on3/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=60, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/SR_width_6/cell1on2/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=90#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=45, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=45, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=45, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=45, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
simEnvF <- envelope.pp3(P, fun=F3est, nsim=45, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))
plot(simEnvF)
simEnvF <- envelope.pp3(P, fun=F3est, nsim=45, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,2))
plot(simEnvF)
simEnvF <- envelope.pp3(P, fun=F3est, nsim=45, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,1))
plot(simEnvF)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/cell3on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=10#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/cell3on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=21#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,100))
plot(simEnvK)
simEnvK
plot(simEnvK$r,simEnvK$mmean)
lines(simEnvK$r,simEnvK$obs)
lines(simEnvK$r,simEnvK$hi,colour="red")
lines(simEnvK$r,simEnvK$hi,type="line", colour="red")
lines(simEnvK$r,simEnvK$hi,type="line", color="red")
lines(simEnvK$r,simEnvK$lo,colour="red")
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/cell3on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=43#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/cell3on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=78#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim39, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=39, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=39, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=39, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
simEnvF <- envelope.pp3(P, fun=F3est, nsim=39, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))
plot(simEnvF)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vraj004/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/cell3on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=89#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=44, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=44, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=44, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=44, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=84#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=42, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=42, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=42, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=42, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#library(s20x)#
#layout20x(2,2)#
#plot(simEnvF)#
#plot(simEnvG)#
#plot(simEnvK)#
#plot(simEnvP)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
d=read.csv(paste(path2,"d_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
D = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
D[as.matrix(w)]<-d$d #
numMeasures = 9#
numSim=43#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsd <- D[as.matrix(allX_pix)]#
oDistMeasure=numeric(numMeasures)#
oDistMeasure[1] <- mean(obsd)#
oDistMeasure[2] <- sd(obsd) #
oDistMeasure[3:9] <- quantile(obsd,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=5,nrval=100)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pKout$r#
#low = 1#
#high=63#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,10))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
#library(s20x)#
#layout20x(2,2)#
#plot(simEnvF)#
#plot(simEnvG)#
#plot(simEnvK)#
#plot(simEnvP)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
#l=apply(W,2,min)#
#u=apply(W,2,max)#
#vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
#u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
#l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
#block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
#X_block = X[block,]#
#allX = X#
#allX_pix=X_pix#
#X=X_block#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
#w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
#Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#Drad[as.matrix(w)]<-drad$d #
#Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numSim=43#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
#obsdrad <- Drad[as.matrix(allX_pix)]#
#oDistRadMeasure=numeric(numMeasures)#
#oDistRadMeasure[1] <- mean(obsdrad)#
#oDistRadMeasure[2] <- sd(obsdrad) #
#oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
#obsdaxi <- Drad[as.matrix(allX_pix)]#
#oDistAxiMeasure=numeric(numMeasures)#
#oDistAxiMeasure[1] <- mean(obsdaxi)#
#oDistAxiMeasure[2] <- sd(obsdaxi) #
#oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
#obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
#oNNdMeasure=numeric(numMeasures)#
#oNNdMeasure[1] <- mean(obsNNd)#
#oNNdMeasure[2] <- sd(obsNNd) #
#oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
########draw envelopes#####
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
   Sblock[[i]] = S[[i]][block,]#
}#
#r=seq(0,1,length=100)#
#curves=list(numSim)#
#for (i in 1:numSim) {#
#   check=findDist(Sblock[[i]],S[[i]])#
#   nPts = dim(check)[1]#
#   curves[[i]] = numeric(100)#
#   for (j in 1:100) {   	  #
#      curves[[i]][j] = (sum(check<=r[j]))/nPts#
#   }#
#   rm(check)#
#}#
#
# Start PNG device driver to save output to figure.png#
#png(filename=paste(path3,"cell2_envelope_cell3_obs_v2.png",sep=""), height=295, width=300, #
# bg="white")#
#
#simCurves=do.call(rbind,curves)#
#ordCurves=apply(simCurves,2,sort)#
#plot(r,ordCurves[1,],type="l",main="Cell 1 Envelope with Observed Cell 1")#
#lines(r,ordCurves[numSim,])#
#
#act = findDist(X,allX)#
#nPts = dim(act)[1]#
#actCurve = numeric(100)#
#for (j in 1:100) {#
#	  numPointsinball = 0#
#   	  for (k in 1:322920){#
#   	  if (act[k]<=r[j]){numPointsinball=numPointsinball+1}#
#   	  }#
#
#  actCurve[j] = (numPointsinball-1)/nPts#
#}#
#lines(r,actCurve,col="red")#
# dev.off()#
#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
Sblock=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
###fix for evans dodgey data##############################################
#   block = apply( S[[i]],1,function(z){all((l_block<=z)&(z<=u_block))} )#
#   Sblock[[i]] = S[[i]][block,]#
##########################################################################
   sP[[i]]=pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
   #sP[[i]]=pp3(Sblock[[i]][,1],Sblock[[i]][,2],Sblock[[i]][,3],box3(c(l[1],u[1]),c(l[2],u[2]),c(l[3],u[3])))#
}#
#
##############Cam's envelope########################
#
#pKout=K3est(P,rmax=5,nrval=100)#
#pGout=G3est(P,rmax=100,nrval=1000)#
#pFout=F3est(P,rmax=5,nrval=100)#
#pPout=pcf3est(P,rmax=5,nrval=100)#
#
#simK=list(numSim)#
#simG=list(numSim)#
#simF=list(numSim)#
#simP=list(numSim)#
#curvesK=list(numSim)#
#curvesG=list(numSim)#
#curvesF=list(numSim)#
#curvesP=list(numSim)#
#for (i in 1:numSim) {#
#   simK[[i]]=K3est(sP[[i]],rmax=5,nrval=100)#
#   simG[[i]]=G3est(sP[[i]],rmax=5,nrval=100)#
#   simF[[i]]=F3est(sP[[i]],rmax=5,nrval=100)#
#   simP[[i]]=pcf3est(sP[[i]],rmax=5,nrval=100)#
#   curvesK[[i]]=simK[[i]]$iso#
#   curvesG[[i]]=simG[[i]]$km#
#   curvesF[[i]]=simF[[i]]$km#
#   curvesP[[i]]=simP[[i]]$iso#
#}#
#simCurves=do.call(rbind,curvesK)#
#ordCurvesK=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesG)#
#ordCurvesG=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesF)#
#ordCurvesF=apply(simCurves,2,sort)#
#simCurves=do.call(rbind,curvesP)#
#ordCurvesP=apply(simCurves,2,sort)#
#
#layout20x(2,2)#
#r=pGout$r#
#low = 1#
#high=numSim#
###do envelopes#
#plot(r,ordCurvesK[low,],type="l",main="Envelope for K Function")#
#lines(r,ordCurvesK[high,])#
#lines(r,pKout$iso,col="red")#
#plot(r,ordCurvesG[low,],type="l",main="Envelope for G Function")#
#lines(r,ordCurvesG[high,])#
#lines(r,pGout$km,col="red")#
#plot(r,ordCurvesF[low,],type="l",main="Envelope for F Function")#
#lines(r,ordCurvesF[high,])#
#lines(r,pFout$km,col="red")#
#plot(r,ordCurvesP[low,],type="l",main="Envelope for pcf Function")#
#lines(r,ordCurvesP[high,])#
#lines(r,pPout$iso,col="red")#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=21, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
# Start PNG device driver to save output to figure.png#
png(filename=paste(path3,"cell3on3_obsdrad.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdrad,breaks="Scott",xlab="Radial Distance of RyR cluster from Z-disc",main="Cell 3 on Cell 3")#
 dev.off()#
png(filename=paste(path3,"cell3on3_obsdaxi.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdaxi,breaks="Scott",xlab="Axial Distance of RyR cluster from Z-disc",main="Cell 3 on Cell 3")#
 dev.off()#
png(filename=paste(path3,"cell3on3_obsnnd.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsNNd,breaks="Scott",xlab="Nearest Neighbour Distances for RyR clusters",main="Cell 3 on Cell 3")#
 dev.off()#
oldVol_obsBox = vol_obsBox#
#####introduce intensity factor - October 11 2012#
 factor = 1 #no change of intensity#
# factor = 0.7 #70% intensity#
###FOLOWING USED IF CHANGING CELL - commented out here#
##read in info for vijay's cell#
##w = read.table(paste(path3,"Cell10_available_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
W=read.csv(paste(path4,"W_micron.txt",sep=""),header=T) #
w = read.csv(paste(path4,"W_pixel.txt",sep=""),header=T)#
#W = (w - 1)*res#
##d = read.table(paste(path3,"Cell10_dFunc_avs_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
drad = read.csv(paste(path4,"d_radial_micron.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Drad[as.matrix(w)]<-abs(drad$d)#
##
daxi = read.csv(paste(path4,"d_axial_micron.txt",sep=""),header=T)#
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Daxi[as.matrix(w)]<-abs(daxi$d)#
##
#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
#u_block = 0.9*(u-l)#
#l_block = 0.1*(u-l)#
#t1 <- proc.time() #timer#
#N=floor((length(allX$x)/oldVol_obsBox)*vol_obsBox*factor)#
N=262#
sim_convgdE = numeric(numPatterns)#
for (j in 1:numPatterns) {#
	# define initial simulated point pattern and data structures#
	simX=matrix(0,nrow=N,ncol=3)#
	ptsIndex=sample(1:length(W$x),N)#
	simX=as.matrix(W[ptsIndex,])#
	avail=(1:length(W$x))[-ptsIndex]#
	simdrad=Drad[as.matrix(w[ptsIndex,])]#
	simDistRadMeasure=numeric(numMeasures)#
	simDistRadMeasure[1] <- mean(simdrad)#
	simDistRadMeasure[2] <- sd(simdrad) #
	simDistRadMeasure[3:9] <- quantile(simdrad,seq(0.125,0.875,length=7))#
	simdaxi=Daxi[as.matrix(w[ptsIndex,])]#
	simDistAxiMeasure=numeric(numMeasures)#
	simDistAxiMeasure[1] <- mean(simdaxi)#
	simDistAxiMeasure[2] <- sd(simdaxi) #
	simDistAxiMeasure[3:9] <- quantile(simdaxi,seq(0.125,0.875,length=7))#
	simNNd = findObsNNDist_CGW(simX,simX,l,u)#
	indSimNNd= findWhichObsNNDist_CGW(simX,simX,l,u)#
	simNNdMeasure=numeric(numMeasures)#
	simNNdMeasure[1] <- mean(simNNd)#
	simNNdMeasure[2] <- sd(simNNd) #
	simNNdMeasure[3:9] <- quantile(simNNd,seq(0.125,0.875,length=7))#
	E <- sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(simDistRadMeasure[1:numMeasures],simDistAxiMeasure[1:numMeasures],simNNdMeasure[1:numMeasures]))^2)#
    propE<-E;#
    cat(propE)#
	propSimDistRadMeasure=numeric(numMeasures)#
	propSimDistAxiMeasure=numeric(numMeasures)#
	propSimNNdMeasure=numeric(numMeasures)#
	i=0;#
	numIter = 80000#
	etol = 0.0003#
	while((i<=numIter)&&(propE>etol) ) {#
#	while((propE>0.00005) ) {#
		  i=i+1;#
	      if (i%%100 == 0) {#
	         cat(i,E,"\n")#
	      }#
	      draw1=sample(1:length(avail),1) #draw from sample of available point indices#
	      draw2=sample(1:length(ptsIndex),1) #draw from index of ryr points currently estimated#
	      propSimX = simX  #set up proposed sim array strucure#
	      propIndSimNNd = indSimNNd #indices of nearest neighbors#
	      propSimX[draw2,]= as.matrix(W[avail[draw1],]) #put in coordinates of randomly chosen new point into proposed sim#
	      propSimNNd = simNNd #
	      #which points had removed point as nearest#
	      gone=which(sapply(indSimNNd,function(z){match(draw2,z)})>0)#
      	#find distance from each remaining point to new point#
	      ndt = findObsNNDist_CGW(as.matrix(propSimX[-draw2,]),t(as.matrix(propSimX[draw2,])),l,u) #find nearest neighbor distances between prop sim x's points to new point draw2#
      	#if new point is nearer than nearest, update#
	      propSimNNd[-draw2] = apply(cbind(propSimNNd[-draw2],ndt),1,min)#
	      propIndSimNNd[-draw2][which(propSimNNd[-draw2]==ndt)]=draw2#
      	#store distance of nearest point to new point#
	      propSimNNd[draw2] = min(ndt)#
      	propIndSimNNd[draw2] = which.min(ndt)#
	      #recalculate nearest point for any pts which had removed point as nearest#
      	if (length(gone)>0) {#
	         for (k in 1:length(gone)) {#
	            propSimNNd[gone[k]] = findObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
      	      propIndSimNNd[gone[k]] = findWhichObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
	         }#
	      }#
      	propSimdrad = simdrad#
	    propSimdrad[draw2] = Drad[as.matrix(w[avail[draw1],])]#
		propSimDistRadMeasure[1] <- mean(propSimdrad)#
		propSimDistRadMeasure[2] <- sd(propSimdrad) #
		propSimDistRadMeasure[3:9] <- quantile(propSimdrad,seq(0.125,0.875,length=7))#
      	propSimdaxi = simdaxi#
	    propSimdaxi[draw2] = Daxi[as.matrix(w[avail[draw1],])]#
		propSimDistAxiMeasure[1] <- mean(propSimdaxi)#
		propSimDistAxiMeasure[2] <- sd(propSimdaxi) #
		propSimDistAxiMeasure[3:9] <- quantile(propSimdaxi,seq(0.125,0.875,length=7))#
#
		propSimNNdMeasure[1] <- mean(propSimNNd)#
		propSimNNdMeasure[2] <- sd(propSimNNd) #
		propSimNNdMeasure[3:9] <- quantile(propSimNNd,seq(0.125,0.875,length=7))#
		propE = sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(propSimDistRadMeasure[1:numMeasures],propSimDistAxiMeasure[1:numMeasures],propSimNNdMeasure[1:numMeasures]))^2)#
		if (propE < E) { # no probability of non-acceptance#
            	cat(propE,"\n")#
			E <- propE  #
			simDistRadMeasure <- propSimDistRadMeasure # this is the new accepted simulated distance function mean#
			simDistAxiMeasure <- propSimDistAxiMeasure # this is the new accepted simulated distance function mean#
			simNNdMeasure <- propSimNNdMeasure # this is the new accepted simulated mean distances mean#
			simX <- propSimX # this is the new accepted simulated point pattern#
			temp = ptsIndex[draw2]#
            	ptsIndex[draw2] = avail[draw1]#
            	avail[draw1] = temp#
            	simdrad = propSimdrad#
            	simdaxi = propSimdaxi#
            	simNNd = propSimNNd#
			indSimNNd = propIndSimNNd#
		}#
	}#
	if(1){#
		sim_convgdE[j] <- E#
		write(t(simX),file=paste(path3,"simPP",j,".txt",sep=""),ncolumns=3,sep='\t')#
	}#
	else j=j-1#
}#
#t2 <- proc.time()#
#print(t2-t1)#
#write out the list of final E values for the each of the converged patterns#
write(sim_convgdE,file=paste(path3,"sim_convgdE",".txt",sep=""),ncolumns=1,sep='\t')#
for (j in 1:numPatterns) {#
   P=read.table(paste(path3,"simPP",j,".txt",sep=""),header=F)#
   block = apply( P,1,function(z){all((l_block<=z)&(z<=u_block))} )#
   P_block = P[block,]#
   write(t(P_block),file=paste(path3,"simPP_block",j,".txt",sep=""),ncolumns=3,sep='\t')#
}
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
# Start PNG device driver to save output to figure.png#
png(filename=paste(path3,"cell3on3_obsdrad.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdrad,breaks="Scott",xlab="Radial Distance of RyR cluster from Z-disc",main="Cell 3 on Cell 3")#
 dev.off()#
png(filename=paste(path3,"cell3on3_obsdaxi.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdaxi,breaks="Scott",xlab="Axial Distance of RyR cluster from Z-disc",main="Cell 3 on Cell 3")#
 dev.off()#
png(filename=paste(path3,"cell3on3_obsnnd.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsNNd,breaks="Scott",xlab="Nearest Neighbour Distances for RyR clusters",main="Cell 3 on Cell 3")#
 dev.off()#
oldVol_obsBox = vol_obsBox#
#####introduce intensity factor - October 11 2012#
 factor = 1 #no change of intensity#
# factor = 0.7 #70% intensity#
###FOLOWING USED IF CHANGING CELL - commented out here#
##read in info for vijay's cell#
##w = read.table(paste(path3,"Cell10_available_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
W=read.csv(paste(path4,"W_micron.txt",sep=""),header=T) #
w = read.csv(paste(path4,"W_pixel.txt",sep=""),header=T)#
#W = (w - 1)*res#
##d = read.table(paste(path3,"Cell10_dFunc_avs_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
drad = read.csv(paste(path4,"d_radial_micron.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Drad[as.matrix(w)]<-abs(drad$d)#
##
daxi = read.csv(paste(path4,"d_axial_micron.txt",sep=""),header=T)#
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Daxi[as.matrix(w)]<-abs(daxi$d)#
##
#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
#u_block = 0.9*(u-l)#
#l_block = 0.1*(u-l)#
#t1 <- proc.time() #timer#
#N=floor((length(allX$x)/oldVol_obsBox)*vol_obsBox*factor)#
N=262#
sim_convgdE = numeric(numPatterns)#
for (j in 1:numPatterns) {#
	# define initial simulated point pattern and data structures#
	simX=matrix(0,nrow=N,ncol=3)#
	ptsIndex=sample(1:length(W$x),N)#
	simX=as.matrix(W[ptsIndex,])#
	avail=(1:length(W$x))[-ptsIndex]#
	simdrad=Drad[as.matrix(w[ptsIndex,])]#
	simDistRadMeasure=numeric(numMeasures)#
	simDistRadMeasure[1] <- mean(simdrad)#
	simDistRadMeasure[2] <- sd(simdrad) #
	simDistRadMeasure[3:9] <- quantile(simdrad,seq(0.125,0.875,length=7))#
	simdaxi=Daxi[as.matrix(w[ptsIndex,])]#
	simDistAxiMeasure=numeric(numMeasures)#
	simDistAxiMeasure[1] <- mean(simdaxi)#
	simDistAxiMeasure[2] <- sd(simdaxi) #
	simDistAxiMeasure[3:9] <- quantile(simdaxi,seq(0.125,0.875,length=7))#
	simNNd = findObsNNDist_CGW(simX,simX,l,u)#
	indSimNNd= findWhichObsNNDist_CGW(simX,simX,l,u)#
	simNNdMeasure=numeric(numMeasures)#
	simNNdMeasure[1] <- mean(simNNd)#
	simNNdMeasure[2] <- sd(simNNd) #
	simNNdMeasure[3:9] <- quantile(simNNd,seq(0.125,0.875,length=7))#
	E <- sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(simDistRadMeasure[1:numMeasures],simDistAxiMeasure[1:numMeasures],simNNdMeasure[1:numMeasures]))^2)#
    propE<-E;#
    cat(propE)#
	propSimDistRadMeasure=numeric(numMeasures)#
	propSimDistAxiMeasure=numeric(numMeasures)#
	propSimNNdMeasure=numeric(numMeasures)#
	i=0;#
	numIter = 100000#
	etol = 0.0003#
	while((i<=numIter)&&(propE>etol) ) {#
#	while((propE>0.00005) ) {#
		  i=i+1;#
	      if (i%%100 == 0) {#
	         cat(i,E,"\n")#
	      }#
	      draw1=sample(1:length(avail),1) #draw from sample of available point indices#
	      draw2=sample(1:length(ptsIndex),1) #draw from index of ryr points currently estimated#
	      propSimX = simX  #set up proposed sim array strucure#
	      propIndSimNNd = indSimNNd #indices of nearest neighbors#
	      propSimX[draw2,]= as.matrix(W[avail[draw1],]) #put in coordinates of randomly chosen new point into proposed sim#
	      propSimNNd = simNNd #
	      #which points had removed point as nearest#
	      gone=which(sapply(indSimNNd,function(z){match(draw2,z)})>0)#
      	#find distance from each remaining point to new point#
	      ndt = findObsNNDist_CGW(as.matrix(propSimX[-draw2,]),t(as.matrix(propSimX[draw2,])),l,u) #find nearest neighbor distances between prop sim x's points to new point draw2#
      	#if new point is nearer than nearest, update#
	      propSimNNd[-draw2] = apply(cbind(propSimNNd[-draw2],ndt),1,min)#
	      propIndSimNNd[-draw2][which(propSimNNd[-draw2]==ndt)]=draw2#
      	#store distance of nearest point to new point#
	      propSimNNd[draw2] = min(ndt)#
      	propIndSimNNd[draw2] = which.min(ndt)#
	      #recalculate nearest point for any pts which had removed point as nearest#
      	if (length(gone)>0) {#
	         for (k in 1:length(gone)) {#
	            propSimNNd[gone[k]] = findObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
      	      propIndSimNNd[gone[k]] = findWhichObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
	         }#
	      }#
      	propSimdrad = simdrad#
	    propSimdrad[draw2] = Drad[as.matrix(w[avail[draw1],])]#
		propSimDistRadMeasure[1] <- mean(propSimdrad)#
		propSimDistRadMeasure[2] <- sd(propSimdrad) #
		propSimDistRadMeasure[3:9] <- quantile(propSimdrad,seq(0.125,0.875,length=7))#
      	propSimdaxi = simdaxi#
	    propSimdaxi[draw2] = Daxi[as.matrix(w[avail[draw1],])]#
		propSimDistAxiMeasure[1] <- mean(propSimdaxi)#
		propSimDistAxiMeasure[2] <- sd(propSimdaxi) #
		propSimDistAxiMeasure[3:9] <- quantile(propSimdaxi,seq(0.125,0.875,length=7))#
#
		propSimNNdMeasure[1] <- mean(propSimNNd)#
		propSimNNdMeasure[2] <- sd(propSimNNd) #
		propSimNNdMeasure[3:9] <- quantile(propSimNNd,seq(0.125,0.875,length=7))#
		propE = sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(propSimDistRadMeasure[1:numMeasures],propSimDistAxiMeasure[1:numMeasures],propSimNNdMeasure[1:numMeasures]))^2)#
		if (propE < E) { # no probability of non-acceptance#
            	cat(propE,"\n")#
			E <- propE  #
			simDistRadMeasure <- propSimDistRadMeasure # this is the new accepted simulated distance function mean#
			simDistAxiMeasure <- propSimDistAxiMeasure # this is the new accepted simulated distance function mean#
			simNNdMeasure <- propSimNNdMeasure # this is the new accepted simulated mean distances mean#
			simX <- propSimX # this is the new accepted simulated point pattern#
			temp = ptsIndex[draw2]#
            	ptsIndex[draw2] = avail[draw1]#
            	avail[draw1] = temp#
            	simdrad = propSimdrad#
            	simdaxi = propSimdaxi#
            	simNNd = propSimNNd#
			indSimNNd = propIndSimNNd#
		}#
	}#
	if(1){#
		sim_convgdE[j] <- E#
		write(t(simX),file=paste(path3,"simPP",j,".txt",sep=""),ncolumns=3,sep='\t')#
	}#
	else j=j-1#
}#
#t2 <- proc.time()#
#print(t2-t1)#
#write out the list of final E values for the each of the converged patterns#
write(sim_convgdE,file=paste(path3,"sim_convgdE",".txt",sep=""),ncolumns=1,sep='\t')#
for (j in 1:numPatterns) {#
   P=read.table(paste(path3,"simPP",j,".txt",sep=""),header=F)#
   block = apply( P,1,function(z){all((l_block<=z)&(z<=u_block))} )#
   P_block = P[block,]#
   write(t(P_block),file=paste(path3,"simPP_block",j,".txt",sep=""),ncolumns=3,sep='\t')#
}
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 40#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
# Start PNG device driver to save output to figure.png#
png(filename=paste(path3,"cell3on3_obsdrad.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdrad,breaks="Scott",xlab="Radial Distance of RyR cluster from Z-disc",main="Cell 3 on Cell 3")#
 dev.off()#
png(filename=paste(path3,"cell3on3_obsdaxi.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdaxi,breaks="Scott",xlab="Axial Distance of RyR cluster from Z-disc",main="Cell 3 on Cell 3")#
 dev.off()#
png(filename=paste(path3,"cell3on3_obsnnd.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsNNd,breaks="Scott",xlab="Nearest Neighbour Distances for RyR clusters",main="Cell 3 on Cell 3")#
 dev.off()#
oldVol_obsBox = vol_obsBox#
#####introduce intensity factor - October 11 2012#
 factor = 1 #no change of intensity#
# factor = 0.7 #70% intensity#
###FOLOWING USED IF CHANGING CELL - commented out here#
##read in info for vijay's cell#
##w = read.table(paste(path3,"Cell10_available_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
W=read.csv(paste(path4,"W_micron.txt",sep=""),header=T) #
w = read.csv(paste(path4,"W_pixel.txt",sep=""),header=T)#
#W = (w - 1)*res#
##d = read.table(paste(path3,"Cell10_dFunc_avs_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
drad = read.csv(paste(path4,"d_radial_micron.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Drad[as.matrix(w)]<-abs(drad$d)#
##
daxi = read.csv(paste(path4,"d_axial_micron.txt",sep=""),header=T)#
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Daxi[as.matrix(w)]<-abs(daxi$d)#
##
#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
#u_block = 0.9*(u-l)#
#l_block = 0.1*(u-l)#
#t1 <- proc.time() #timer#
#N=floor((length(allX$x)/oldVol_obsBox)*vol_obsBox*factor)#
N=262#
sim_convgdE = numeric(numPatterns)#
for (j in 1:numPatterns) {#
	# define initial simulated point pattern and data structures#
	simX=matrix(0,nrow=N,ncol=3)#
	ptsIndex=sample(1:length(W$x),N)#
	simX=as.matrix(W[ptsIndex,])#
	avail=(1:length(W$x))[-ptsIndex]#
	simdrad=Drad[as.matrix(w[ptsIndex,])]#
	simDistRadMeasure=numeric(numMeasures)#
	simDistRadMeasure[1] <- mean(simdrad)#
	simDistRadMeasure[2] <- sd(simdrad) #
	simDistRadMeasure[3:9] <- quantile(simdrad,seq(0.125,0.875,length=7))#
	simdaxi=Daxi[as.matrix(w[ptsIndex,])]#
	simDistAxiMeasure=numeric(numMeasures)#
	simDistAxiMeasure[1] <- mean(simdaxi)#
	simDistAxiMeasure[2] <- sd(simdaxi) #
	simDistAxiMeasure[3:9] <- quantile(simdaxi,seq(0.125,0.875,length=7))#
	simNNd = findObsNNDist_CGW(simX,simX,l,u)#
	indSimNNd= findWhichObsNNDist_CGW(simX,simX,l,u)#
	simNNdMeasure=numeric(numMeasures)#
	simNNdMeasure[1] <- mean(simNNd)#
	simNNdMeasure[2] <- sd(simNNd) #
	simNNdMeasure[3:9] <- quantile(simNNd,seq(0.125,0.875,length=7))#
	E <- sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(simDistRadMeasure[1:numMeasures],simDistAxiMeasure[1:numMeasures],simNNdMeasure[1:numMeasures]))^2)#
    propE<-E;#
    cat(propE)#
	propSimDistRadMeasure=numeric(numMeasures)#
	propSimDistAxiMeasure=numeric(numMeasures)#
	propSimNNdMeasure=numeric(numMeasures)#
	i=0;#
	numIter = 100000#
	etol = 0.0005#
	while((i<=numIter)&&(propE>etol) ) {#
#	while((propE>0.00005) ) {#
		  i=i+1;#
	      if (i%%100 == 0) {#
	         cat(i,E,"\n")#
	      }#
	      draw1=sample(1:length(avail),1) #draw from sample of available point indices#
	      draw2=sample(1:length(ptsIndex),1) #draw from index of ryr points currently estimated#
	      propSimX = simX  #set up proposed sim array strucure#
	      propIndSimNNd = indSimNNd #indices of nearest neighbors#
	      propSimX[draw2,]= as.matrix(W[avail[draw1],]) #put in coordinates of randomly chosen new point into proposed sim#
	      propSimNNd = simNNd #
	      #which points had removed point as nearest#
	      gone=which(sapply(indSimNNd,function(z){match(draw2,z)})>0)#
      	#find distance from each remaining point to new point#
	      ndt = findObsNNDist_CGW(as.matrix(propSimX[-draw2,]),t(as.matrix(propSimX[draw2,])),l,u) #find nearest neighbor distances between prop sim x's points to new point draw2#
      	#if new point is nearer than nearest, update#
	      propSimNNd[-draw2] = apply(cbind(propSimNNd[-draw2],ndt),1,min)#
	      propIndSimNNd[-draw2][which(propSimNNd[-draw2]==ndt)]=draw2#
      	#store distance of nearest point to new point#
	      propSimNNd[draw2] = min(ndt)#
      	propIndSimNNd[draw2] = which.min(ndt)#
	      #recalculate nearest point for any pts which had removed point as nearest#
      	if (length(gone)>0) {#
	         for (k in 1:length(gone)) {#
	            propSimNNd[gone[k]] = findObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
      	      propIndSimNNd[gone[k]] = findWhichObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
	         }#
	      }#
      	propSimdrad = simdrad#
	    propSimdrad[draw2] = Drad[as.matrix(w[avail[draw1],])]#
		propSimDistRadMeasure[1] <- mean(propSimdrad)#
		propSimDistRadMeasure[2] <- sd(propSimdrad) #
		propSimDistRadMeasure[3:9] <- quantile(propSimdrad,seq(0.125,0.875,length=7))#
      	propSimdaxi = simdaxi#
	    propSimdaxi[draw2] = Daxi[as.matrix(w[avail[draw1],])]#
		propSimDistAxiMeasure[1] <- mean(propSimdaxi)#
		propSimDistAxiMeasure[2] <- sd(propSimdaxi) #
		propSimDistAxiMeasure[3:9] <- quantile(propSimdaxi,seq(0.125,0.875,length=7))#
#
		propSimNNdMeasure[1] <- mean(propSimNNd)#
		propSimNNdMeasure[2] <- sd(propSimNNd) #
		propSimNNdMeasure[3:9] <- quantile(propSimNNd,seq(0.125,0.875,length=7))#
		propE = sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(propSimDistRadMeasure[1:numMeasures],propSimDistAxiMeasure[1:numMeasures],propSimNNdMeasure[1:numMeasures]))^2)#
		if (propE < E) { # no probability of non-acceptance#
            	cat(propE,"\n")#
			E <- propE  #
			simDistRadMeasure <- propSimDistRadMeasure # this is the new accepted simulated distance function mean#
			simDistAxiMeasure <- propSimDistAxiMeasure # this is the new accepted simulated distance function mean#
			simNNdMeasure <- propSimNNdMeasure # this is the new accepted simulated mean distances mean#
			simX <- propSimX # this is the new accepted simulated point pattern#
			temp = ptsIndex[draw2]#
            	ptsIndex[draw2] = avail[draw1]#
            	avail[draw1] = temp#
            	simdrad = propSimdrad#
            	simdaxi = propSimdaxi#
            	simNNd = propSimNNd#
			indSimNNd = propIndSimNNd#
		}#
	}#
	if(1){#
		sim_convgdE[j] <- E#
		write(t(simX),file=paste(path3,"simPP",j,".txt",sep=""),ncolumns=3,sep='\t')#
	}#
	else j=j-1#
}#
#t2 <- proc.time()#
#print(t2-t1)#
#write out the list of final E values for the each of the converged patterns#
write(sim_convgdE,file=paste(path3,"sim_convgdE",".txt",sep=""),ncolumns=1,sep='\t')#
for (j in 1:numPatterns) {#
   P=read.table(paste(path3,"simPP",j,".txt",sep=""),header=F)#
   block = apply( P,1,function(z){all((l_block<=z)&(z<=u_block))} )#
   P_block = P[block,]#
   write(t(P_block),file=paste(path3,"simPP_block",j,".txt",sep=""),ncolumns=3,sep='\t')#
}
path3
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
# Start PNG device driver to save output to figure.png#
png(filename=paste(path3,"cell4on4_obsdrad.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdrad,breaks="Scott",xlab="Radial Distance of RyR cluster from Z-disc",main="Cell 4 on Cell 4")#
 dev.off()#
png(filename=paste(path3,"cell4on4_obsdaxi.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdaxi,breaks="Scott",xlab="Axial Distance of RyR cluster from Z-disc",main="Cell 4 on Cell 4")#
 dev.off()#
png(filename=paste(path3,"cell4on4_obsnnd.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsNNd,breaks="Scott",xlab="Nearest Neighbour Distances for RyR clusters",main="Cell 4 on Cell 4")#
 dev.off()#
oldVol_obsBox = vol_obsBox#
#####introduce intensity factor - October 11 2012#
 factor = 1 #no change of intensity#
# factor = 0.7 #70% intensity#
###FOLOWING USED IF CHANGING CELL - commented out here#
##read in info for vijay's cell#
##w = read.table(paste(path3,"Cell10_available_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
W=read.csv(paste(path4,"W_micron.txt",sep=""),header=T) #
w = read.csv(paste(path4,"W_pixel.txt",sep=""),header=T)#
#W = (w - 1)*res#
##d = read.table(paste(path3,"Cell10_dFunc_avs_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
drad = read.csv(paste(path4,"d_radial_micron.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Drad[as.matrix(w)]<-abs(drad$d)#
##
daxi = read.csv(paste(path4,"d_axial_micron.txt",sep=""),header=T)#
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Daxi[as.matrix(w)]<-abs(daxi$d)#
##
#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
#u_block = 0.9*(u-l)#
#l_block = 0.1*(u-l)#
#t1 <- proc.time() #timer#
#N=floor((length(allX$x)/oldVol_obsBox)*vol_obsBox*factor)#
N=636#
sim_convgdE = numeric(numPatterns)#
for (j in 1:numPatterns) {#
	# define initial simulated point pattern and data structures#
	simX=matrix(0,nrow=N,ncol=3)#
	ptsIndex=sample(1:length(W$x),N)#
	simX=as.matrix(W[ptsIndex,])#
	avail=(1:length(W$x))[-ptsIndex]#
	simdrad=Drad[as.matrix(w[ptsIndex,])]#
	simDistRadMeasure=numeric(numMeasures)#
	simDistRadMeasure[1] <- mean(simdrad)#
	simDistRadMeasure[2] <- sd(simdrad) #
	simDistRadMeasure[3:9] <- quantile(simdrad,seq(0.125,0.875,length=7))#
	simdaxi=Daxi[as.matrix(w[ptsIndex,])]#
	simDistAxiMeasure=numeric(numMeasures)#
	simDistAxiMeasure[1] <- mean(simdaxi)#
	simDistAxiMeasure[2] <- sd(simdaxi) #
	simDistAxiMeasure[3:9] <- quantile(simdaxi,seq(0.125,0.875,length=7))#
	simNNd = findObsNNDist_CGW(simX,simX,l,u)#
	indSimNNd= findWhichObsNNDist_CGW(simX,simX,l,u)#
	simNNdMeasure=numeric(numMeasures)#
	simNNdMeasure[1] <- mean(simNNd)#
	simNNdMeasure[2] <- sd(simNNd) #
	simNNdMeasure[3:9] <- quantile(simNNd,seq(0.125,0.875,length=7))#
	E <- sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(simDistRadMeasure[1:numMeasures],simDistAxiMeasure[1:numMeasures],simNNdMeasure[1:numMeasures]))^2)#
    propE<-E;#
    cat(propE)#
	propSimDistRadMeasure=numeric(numMeasures)#
	propSimDistAxiMeasure=numeric(numMeasures)#
	propSimNNdMeasure=numeric(numMeasures)#
	i=0;#
	numIter = 200000#
	etol = 0.0005#
	while((i<=numIter)&&(propE>etol) ) {#
#	while((propE>0.00005) ) {#
		  i=i+1;#
	      if (i%%100 == 0) {#
	         cat(i,E,"\n")#
	      }#
	      draw1=sample(1:length(avail),1) #draw from sample of available point indices#
	      draw2=sample(1:length(ptsIndex),1) #draw from index of ryr points currently estimated#
	      propSimX = simX  #set up proposed sim array strucure#
	      propIndSimNNd = indSimNNd #indices of nearest neighbors#
	      propSimX[draw2,]= as.matrix(W[avail[draw1],]) #put in coordinates of randomly chosen new point into proposed sim#
	      propSimNNd = simNNd #
	      #which points had removed point as nearest#
	      gone=which(sapply(indSimNNd,function(z){match(draw2,z)})>0)#
      	#find distance from each remaining point to new point#
	      ndt = findObsNNDist_CGW(as.matrix(propSimX[-draw2,]),t(as.matrix(propSimX[draw2,])),l,u) #find nearest neighbor distances between prop sim x's points to new point draw2#
      	#if new point is nearer than nearest, update#
	      propSimNNd[-draw2] = apply(cbind(propSimNNd[-draw2],ndt),1,min)#
	      propIndSimNNd[-draw2][which(propSimNNd[-draw2]==ndt)]=draw2#
      	#store distance of nearest point to new point#
	      propSimNNd[draw2] = min(ndt)#
      	propIndSimNNd[draw2] = which.min(ndt)#
	      #recalculate nearest point for any pts which had removed point as nearest#
      	if (length(gone)>0) {#
	         for (k in 1:length(gone)) {#
	            propSimNNd[gone[k]] = findObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
      	      propIndSimNNd[gone[k]] = findWhichObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
	         }#
	      }#
      	propSimdrad = simdrad#
	    propSimdrad[draw2] = Drad[as.matrix(w[avail[draw1],])]#
		propSimDistRadMeasure[1] <- mean(propSimdrad)#
		propSimDistRadMeasure[2] <- sd(propSimdrad) #
		propSimDistRadMeasure[3:9] <- quantile(propSimdrad,seq(0.125,0.875,length=7))#
      	propSimdaxi = simdaxi#
	    propSimdaxi[draw2] = Daxi[as.matrix(w[avail[draw1],])]#
		propSimDistAxiMeasure[1] <- mean(propSimdaxi)#
		propSimDistAxiMeasure[2] <- sd(propSimdaxi) #
		propSimDistAxiMeasure[3:9] <- quantile(propSimdaxi,seq(0.125,0.875,length=7))#
#
		propSimNNdMeasure[1] <- mean(propSimNNd)#
		propSimNNdMeasure[2] <- sd(propSimNNd) #
		propSimNNdMeasure[3:9] <- quantile(propSimNNd,seq(0.125,0.875,length=7))#
		propE = sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(propSimDistRadMeasure[1:numMeasures],propSimDistAxiMeasure[1:numMeasures],propSimNNdMeasure[1:numMeasures]))^2)#
		if (propE < E) { # no probability of non-acceptance#
            	cat(propE,"\n")#
			E <- propE  #
			simDistRadMeasure <- propSimDistRadMeasure # this is the new accepted simulated distance function mean#
			simDistAxiMeasure <- propSimDistAxiMeasure # this is the new accepted simulated distance function mean#
			simNNdMeasure <- propSimNNdMeasure # this is the new accepted simulated mean distances mean#
			simX <- propSimX # this is the new accepted simulated point pattern#
			temp = ptsIndex[draw2]#
            	ptsIndex[draw2] = avail[draw1]#
            	avail[draw1] = temp#
            	simdrad = propSimdrad#
            	simdaxi = propSimdaxi#
            	simNNd = propSimNNd#
			indSimNNd = propIndSimNNd#
		}#
	}#
	if(1){#
		sim_convgdE[j] <- E#
		write(t(simX),file=paste(path3,"simPP",j,".txt",sep=""),ncolumns=3,sep='\t')#
	}#
	else j=j-1#
}#
#t2 <- proc.time()#
#print(t2-t1)#
#write out the list of final E values for the each of the converged patterns#
write(sim_convgdE,file=paste(path3,"sim_convgdE",".txt",sep=""),ncolumns=1,sep='\t')#
for (j in 1:numPatterns) {#
   P=read.table(paste(path3,"simPP",j,".txt",sep=""),header=F)#
   block = apply( P,1,function(z){all((l_block<=z)&(z<=u_block))} )#
   P_block = P[block,]#
   write(t(P_block),file=paste(path3,"simPP_block",j,".txt",sep=""),ncolumns=3,sep='\t')#
}
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/cell4on1/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=13#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
P
sP[[2]]
plot([[sP2]])
plot(sP[[2]])
plot(sP[[1]])
plot(sP[[5]])
plot(sP[[10]])
plot(sP[[112]])
plot(sP[[12]])
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/cell4on1/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=13#
library(spatstat)#
library(s20x)#
#
x_u=1.05*max(X$x)#
x_l=.95*min(X$x)#
y_u=1.05*max(X$y)#
y_l=.95*min(X$y)#
z_u=1.05*max(X$z)#
z_l=.95*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
P
sP[[1]]
plot(P)
plot(sP[[2]])
plot(sP[[1]])
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/cell4on1/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=13#
library(spatstat)#
library(s20x)#
#
x_u=1.1*max(X$x)#
x_l=.9*min(X$x)#
y_u=1.1*max(X$y)#
y_l=.9*min(X$y)#
z_u=1.1*max(X$z)#
z_l=.9*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=6, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
P
jb = box3(c(0,1),c(0,1),c(0,1))
jP<-pp3(X$x,X$y,X$z,jb)
jP
plot(jP)
jP
plot(P)
plot(jP)
plot(sP[[1]])
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/cell4on1/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))
oNNdMeasure
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/cell1on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))
oNNdMeasure
oDistRadMeasure
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/cell2on3/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))
oNNdMeasure
oDistAxiMeasure
oDistRadMeasure
oNNdMeasure
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/cell2on3/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))
oNNdMeasure
oDistRadMeasure
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/cell2on3/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))
oDistRadMeasure
oDistAxiMeasure
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/cell2on3/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X as measured by Evan, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
## define background distance transform 3D array#
##w <- W/res+1 #w is the voxel coordinates version of W. #
#W2=W#
#W2[,1] = W2[,1] - min(W2[,1])#
#W2[,2] = W2[,2] - min(W2[,2])#
#W2[,3] = W2[,3] - min(W2[,3])#
##
#w<-W2#
#w[,1] <- w[,1]/resx+1#
#w[,2] <- w[,2]/resy+1#
#w[,3] <- w[,3]/resz+1#
##
#w<-round(w)#
##store the distance function as a hash table allowing for easy table look up when doing the reconstruction simulation.#
#D = array(dim=round(u/res)+1) #
#D[as.matrix(w)]<-d$d #
w=read.csv(paste(path2,"W_pixel.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
numMeasures = 9#
numPatterns = 120#
# compute the observed measures for distance#
#obsd <- D[as.matrix(allX/res+1)] #
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))
oDistAxiMeasure
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/cell2on3/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=10#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/cell2on3/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=16#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=8, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=8, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=8, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=8, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
rm(list=ls())
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/cell1on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=16#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
plot(P)
plot(sP[[4]])
P
sP[[1]]
plot(P)
sP[[1]]
plot(sP[[4]])
plot(P)
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/cell1on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=16#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/cell1on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=14#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=7, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=7, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=7, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=7, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/cell2on3/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=28#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=14, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=14, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=14, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=14, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/cell2on3/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=43#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=22, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=22, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=22, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=22, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/cell1on4/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell4_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=21#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=5#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=4, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=4, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=4, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=4, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=6#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=3, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=3, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=3, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=3, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=8#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=4, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=4, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=4, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=4, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=11#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=5, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=40#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=40#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=40#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=40#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
plot(P)
plot(sP[[5]])
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=40#
library(spatstat)#
library(s20x)#
#
x_u=1.01*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
plot(P)
plot(sP[[1]])
plot(sP[[2]])
plot(sP[[4]])
''
max(X$x)
max(S[[1]]$x)
S[[1]]
S[[1]]$x
S[[1]]$V!
S[[1]]$V1
max(S[[1]]$V1)
max(X$x)
22.111*1.1
max(X$z)
max(S[[1]]$V3)
max(S[[1]]$V2)
max(X$y)
min(S[[1]]$V3)
min(X$z)
0.99*4.818
meam(X$z)
mean(X$z)
mean(S[[1]]$V3)
S[[1]]$V3
hist(S[[1]]$V3)
hist(X$z)
hist(S[[1]]$V3,breaks="Scott")
hist(X$z,breaks="Scott")
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell1_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=40#
library(spatstat)#
library(s20x)#
#
x_u=1.02*max(X$x)#
x_l=.98*min(X$x)#
y_u=1.02*max(X$y)#
y_l=.98*min(X$y)#
z_u=1.02*max(X$z)#
z_l=.98*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
plot({})
plot({P)
plot(P)
plot(sP[[1]])
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell3_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=40#
library(spatstat)#
library(s20x)#
#
x_u=1.02*max(X$x)#
x_l=.99*min(X$x)#
y_u=1.01*max(X$y)#
y_l=.99*min(X$y)#
z_u=1.01*max(X$z)#
z_l=.99*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=10, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
plot(P)
plot(sP[[1]])
hist(X$z,breaks="Scott")
hist(S[[1]]$V3,breaks="Scott")
hist(S[[1]]$V2,breaks="Scott")
hist(X$y,breaks="Scott")
hist(X$x,breaks="Scott")
hist(S[[1]]$V1,breaks="Scott")
hist(S[[1]]$V1,breaks="Scott",freq=FALSE)
plot(P)
hist(S[[1]]$V1,breaks="Scott",freq=FALSE)
hist(S[[1]]$V3,breaks="Scott")
max(X$z)
max(S[[1]]$V3)
max(S[[2]]$V3)
max(S[[3]]$V3)
max(S[[4]]$V3)
max(S[[5]]$V3)
max(S[[6]]$V3)
max(S[[7]]$V3)
max(S[[8]]$V3)
max(S[[9]]$V3)
max(S[[10]]$V3)
max(S[[11]]$V3)
max(S[[12]]$V3)
max(S[[13]]$V3)
max(S[[14]]$V3)
max(S[[15]]$V3)
max(S[[16]]$V3)
min(S[[1]]$V3)
min(X$z)
3.83*1.01
3.83*1.1
Written by Evan Blumgart 02/02/11#
# Modified/commented by Vijay Rajagopal#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# This code implements the Reconstruction Algorithm using the mean of the distance function and nearest neighbour distances as modelling metrics.#
# (Can also using distance function and nearest neighbour distance variances as metrics)#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. #
#(male adult wistar rats)#
#path="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
#path="C:\\Users\\cameron\\Dropbox\\RyR\\"#
path="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/"#
source(paste(path,"CGW_sim.R",sep=""))#
#path2="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path3="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
#path4="/Users/vijayaraghavan/Documents/heart/data/soeller/Bass/Cell1_processing&analysis/MATLAB_outputs/SR_width_9/"#
path2="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
path3="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/output/"#
path4="/Users/vijayaraghavan/Documents/heart/sims/R/camSim/Cell2_data/d_sep_zmod_SR_width_6/"#
#path3="C:\\Users\\cwal003\\Documents\\cam\\Vijay\\RyR\\fromGregBass\\run1Oct118\\"#
#path2="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\output_VJ_2\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\walker_ryrsim_inputs\\"#
#path3="D:\\docs\\Users\\Cameron\\Research\\bioInstitute\\Vijay\\RyR Sim\\Final Data\\"#
##change this to be the new cell, not Evan's cell#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data - stored in a file X.txt#
#X=read.table(paste(path,"X.txt",sep=""),header=T)#
X=read.csv(paste(path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
#allX=read.table(paste(path,"allX.txt",sep=""),header=T)#
allX=read.csv(paste(path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file Wfix.txt#
#W=read.table(paste(path,"Wfix.txt",sep=""),header=T) #why doesn't product of D dims = length(W$x) - are some voxels missing?#
W=read.csv(paste(path2,"W_micron.txt",sep=""),header=T) #
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
#d=read.table(paste(path,"dfix.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
drad=read.csv(paste(path2,"d_radial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path2,"d_axial_micron.txt",sep=""),header=T) #I think this is the distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
numMeasures = 9#
numSim=40#
library(spatstat)#
library(s20x)#
#
x_u=1.2*max(X$x)#
x_l=.8*min(X$x)#
y_u=1.2*max(X$y)#
y_l=.8*min(X$y)#
z_u=1.2*max(X$z)#
z_l=.8*min(X$z)#
#
#create box of observed points; ignore myofibrils in calculation of K, F and G. #
win=box3(c(x_l,x_u),c(y_l,y_u),c(z_l,z_u))#
#
#generate variable P as a point process of the observed ryrs#
P <- pp3(X$x, X$y, X$z, win)#
S=list(numSim)#
sP=list(numSim)#
for (i in 1:numSim){#
   S[[i]]=read.table(paste(path3,"simPP",i,".txt",sep=""),header=F)#
   sP[[i]]<-pp3(S[[i]][,1],S[[i]][,2],S[[i]][,3],win)#
}#
#
#####################Spatstat 3D envelope #
#
simEnvF <- envelope.pp3(P, fun=F3est, nsim=8, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvG <- envelope.pp3(P, fun=G3est, nsim=8, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvK <- envelope.pp3(P, fun=K3est, nsim=8, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
simEnvP <- envelope.pp3(P, fun=pcf3est, nsim=8, simulate=sP, nrank=1,global=TRUE,ginterval=c(0,5))#
library(s20x)#
layout20x(2,2)#
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
plot(simEnvF)#
plot(simEnvG)#
plot(simEnvK)#
plot(simEnvP)
plot(simEnvG)
Modified/corrected/commented by Vijay Rajagopal#
#                             - added split in radial versus axial distance of RyR cluster to Z-disc#
#                             - added termination criteria#
#                             - corrected and validated code#
# Corrected by Cameron Walker #
#                            - sped up (looping removed where possible)#
#                            - torus metric edge correction implemented#
#                            - quantiles added to Energy #
#                            - iterative updating of metrics implemented#
# Original ideas developed in collaboration with Evan Blumgart 02/02/11 (refer to Masters thesis from University of Auckland, 2011)#
# This code implements the Reconstruction Algorithm using the mean and quantiles of the axial and radial distances of RyR clusters from the z-discs and the nearest neighbour distances of the RyR clusters as modelling metrics.#
# FUTURE FEATURE: Can also using distance function and nearest neighbour distance variances as metrics#
#The code first reads in the RyR and z-disk data from an experiment and calculates the nearest neighbour and distance functions. #
#This is then set up as the target statistic that the reconstruction algorithm must recreate on a new z-disk dataset from a different experiement #
#with no RyRs on it. It basically assumes that the RyR characteristics of the first experimental data is typical of the distribution in these cells. This assumption was validated in recent paper (submitted DATE)#
##################
#options(warn=2) - uncomment this for debugging purposes#
###################
setwd("/Users/vijayaraghavan/ryr-simulator/source")#
path=getwd()#
source(paste(path,"/nnd-calculators.R",sep=""))#
path2="/../input-files/master-cell/"#
path3="/../output-files/target-cell/"#
path4="/../input-files/target-cell/"#
# read in the coordinates of all the observed RyR's inside sampling box of the experimental data (master cell) - stored in a file X.txt (read in micron and pixel versions)#
X=read.csv(paste(path,path2,"X_micron.txt",sep=""),header=T)#
X_pix=read.csv(paste(path,path2,"X_pixel.txt",sep=""),header=T)#
# read in whole RyR data cloud of the experimental data stored in a file allX.txt#
allX=read.csv(paste(path,path2,"allX_micron.txt",sep=""),header=T)#
allX_pix=read.csv(paste(path,path2,"allX_pixel.txt",sep=""),header=T)#
# read in non-myofibril voxels of the experimental data stored in a file W.txt#
W=read.csv(paste(path,path2,"W_micron.txt",sep=""),header=T) #
w=read.csv(paste(path,path2,"W_pixel.txt",sep=""),header=T)#
# read in distance function of voxels in W for the experimental data. stored in a file d.txt#
drad=read.csv(paste(path,path2,"d_radial_micron.txt",sep=""),header=T) #Radial distance from given voxel (W) to z-disk#
daxi=read.csv(paste(path,path2,"d_axial_micron.txt",sep=""),header=T) #Axial distance from given voxel (W) to z-disk#
# define box boundaries of the experimental data that we are using to calculate nearest neighbour and distance function statistics.#
#note that directions x1, y1 and z1 have different meanings in different image processing/stats processing codes. So, when reading a file into this code#
#be aware what coordinate system was used in the code that generated that image and the coordinate system used in this code.#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
#Would like to use allX and X, but do not have any of the distance information#
# for allX, so will treat X as allX and take a smaller block within X as X#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
block = apply( X,1,function(z){all((l_block<=z)&(z<=u_block))} )#
X_block = X[block,]#
allX = X#
allX_pix=X_pix#
X=X_block#
# define voxel resolution#
resx = 0.0732157#
resy = 0.0732157#
resz = 0.053535#
res <-c(resx,resy,resz)#
#set up look up table of axial and radial distances from each available voxel for RyR cluster simulation to z-disc#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Drad[as.matrix(w)]<-drad$d #
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
Daxi[as.matrix(w)]<-daxi$d #
#
#number of measures to compare#
numMeasures = 9#
#number of simulation patterns to generate.#
numPatterns = 26#
# compute the observed measures for distance (radial, axial and nearest-neighborhood)#
obsdrad <- Drad[as.matrix(allX_pix)]#
oDistRadMeasure=numeric(numMeasures)#
oDistRadMeasure[1] <- mean(obsdrad)#
oDistRadMeasure[2] <- sd(obsdrad) #
oDistRadMeasure[3:9] <- quantile(obsdrad,seq(0.125,0.875,length=7))#
#axial distances#
obsdaxi <- Daxi[as.matrix(allX_pix)]#
oDistAxiMeasure=numeric(numMeasures)#
oDistAxiMeasure[1] <- mean(obsdaxi)#
oDistAxiMeasure[2] <- sd(obsdaxi) #
oDistAxiMeasure[3:9] <- quantile(obsdaxi,seq(0.125,0.875,length=7))#
#
####replaced X with allX - July 22nd 2012#
####introduced allX_pix instead of using res - Oct 23 2012#
# compute mean of observed measures for nearest neigbour distance#
#obsNNd = findObsNNDist_CGW(X,allX,l,u) # correct for this data - can't simulate all X as W is too small#
#nearest neighborhood distances.#
obsNNd = findObsNNDist_CGW(allX,allX,l,u)#
oNNdMeasure=numeric(numMeasures)#
oNNdMeasure[1] <- mean(obsNNd)#
oNNdMeasure[2] <- sd(obsNNd) #
oNNdMeasure[3:9] <- quantile(obsNNd,seq(0.125,0.875,length=7))#
#set up histogram parameters#
filename="master_cell"#
main = "Master Cell"#
#breaks in distance for each distance type#
nndbreaks = c(0,0.2,0.4,0.6,0.8,1.2)#
radbreaks = c(0,0.2,0.4,0.6,0.8)#
#
# Start PNG device driver to save output to figure.png#
png(filename=paste(path,path3,filename,"_obsdrad.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdrad,breaks=radbreaks,xlab="Radial Distance of RyR cluster from Z-disc",main=main)#
 dev.off()#
png(filename=paste(path,path3,filename,"_obsdaxi.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsdaxi,breaks="Scott",xlab="Axial Distance of RyR cluster from Z-disc",main=main)#
 dev.off()#
png(filename=paste(path,path3,filename,"_obsnnd.png",sep=""), height=295, width=300, #
 bg="white")#
#
 hist(obsNNd,breaks=nndbreaks,xlab="Nearest Neighbour Distances for RyR clusters",main=main)#
 dev.off()#
oldVol_obsBox = vol_obsBox#
#####introduce intensity factor - October 11 2012#
 factor = 1 #no change of intensity#
# factor = 0.7 #70% intensity#
###FOLOWING USED IF CHANGING CELL - commented out here#
##read in info for vijay's cell#
##w = read.table(paste(path3,"Cell10_available_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
W=read.csv(paste(path,path4,"W_micron.txt",sep=""),header=T) #
w = read.csv(paste(path,path4,"W_pixel.txt",sep=""),header=T)#
#W = (w - 1)*res#
##d = read.table(paste(path3,"Cell10_dFunc_avs_lowres_myo_mito_stack_correct_2012.txt",sep=""),header=T)#
drad = read.csv(paste(path,path4,"d_radial_micron.txt",sep=""),header=T)#
Drad = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Drad[as.matrix(w)]<-abs(drad$d)#
##
daxi = read.csv(paste(path,path4,"d_axial_micron.txt",sep=""),header=T)#
Daxi = array(dim=c(max(w[,1]),max(w[,2]),max(w[,3]))) #
#D = array(dim=u/res+1)#
Daxi[as.matrix(w)]<-abs(daxi$d)#
##
#
l=apply(W,2,min)#
u=apply(W,2,max)#
vol_obsBox <- prod(u-l)#
u_block = 0.9*(u-(u-l)/2)+(u-l)/2#
l_block = 0.9*(l-(u-l)/2)+(u-l)/2#
#u_block = 0.9*(u-l)#
#l_block = 0.1*(u-l)#
#t1 <- proc.time() #timer#
#N=floor((length(allX$x)/oldVol_obsBox)*vol_obsBox*factor)#
N=169#
sim_convgdE = numeric(numPatterns)#
for (j in 1:numPatterns) {#
	# define initial simulated point pattern and data structures#
	simX=matrix(0,nrow=N,ncol=3)#
	ptsIndex=sample(1:length(W$x),N)#
	simX=as.matrix(W[ptsIndex,])#
	avail=(1:length(W$x))[-ptsIndex]#
	simdrad=Drad[as.matrix(w[ptsIndex,])]#
	simDistRadMeasure=numeric(numMeasures)#
	simDistRadMeasure[1] <- mean(simdrad)#
	simDistRadMeasure[2] <- sd(simdrad) #
	simDistRadMeasure[3:9] <- quantile(simdrad,seq(0.125,0.875,length=7))#
	simdaxi=Daxi[as.matrix(w[ptsIndex,])]#
	simDistAxiMeasure=numeric(numMeasures)#
	simDistAxiMeasure[1] <- mean(simdaxi)#
	simDistAxiMeasure[2] <- sd(simdaxi) #
	simDistAxiMeasure[3:9] <- quantile(simdaxi,seq(0.125,0.875,length=7))#
	simNNd = findObsNNDist_CGW(simX,simX,l,u)#
	indSimNNd= findWhichObsNNDist_CGW(simX,simX,l,u)#
	simNNdMeasure=numeric(numMeasures)#
	simNNdMeasure[1] <- mean(simNNd)#
	simNNdMeasure[2] <- sd(simNNd) #
	simNNdMeasure[3:9] <- quantile(simNNd,seq(0.125,0.875,length=7))#
	E <- sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(simDistRadMeasure[1:numMeasures],simDistAxiMeasure[1:numMeasures],simNNdMeasure[1:numMeasures]))^2)#
    propE<-E;#
    cat(propE)#
	propSimDistRadMeasure=numeric(numMeasures)#
	propSimDistAxiMeasure=numeric(numMeasures)#
	propSimNNdMeasure=numeric(numMeasures)#
	i=0;#
	numIter = 200000#
	etol = 0.001#
	while((i<=numIter)&&(propE>etol) ) {#
#	while((propE>0.00005) ) {#
		  i=i+1;#
	      if (i%%100 == 0) {#
	         cat(i,E,"\n")#
	      }#
	      draw1=sample(1:length(avail),1) #draw from sample of available point indices#
	      draw2=sample(1:length(ptsIndex),1) #draw from index of ryr points currently estimated#
	      propSimX = simX  #set up proposed sim array strucure#
	      propIndSimNNd = indSimNNd #indices of nearest neighbors#
	      propSimX[draw2,]= as.matrix(W[avail[draw1],]) #put in coordinates of randomly chosen new point into proposed sim#
	      propSimNNd = simNNd #
	      #which points had removed point as nearest#
	      gone=which(sapply(indSimNNd,function(z){match(draw2,z)})>0)#
      	#find distance from each remaining point to new point#
	      ndt = findObsNNDist_CGW(as.matrix(propSimX[-draw2,]),t(as.matrix(propSimX[draw2,])),l,u) #find nearest neighbor distances between prop sim x's points to new point draw2#
      	#if new point is nearer than nearest, update#
	      propSimNNd[-draw2] = apply(cbind(propSimNNd[-draw2],ndt),1,min)#
	      propIndSimNNd[-draw2][which(propSimNNd[-draw2]==ndt)]=draw2#
      	#store distance of nearest point to new point#
	      propSimNNd[draw2] = min(ndt)#
      	propIndSimNNd[draw2] = which.min(ndt)#
	      #recalculate nearest point for any pts which had removed point as nearest#
      	if (length(gone)>0) {#
	         for (k in 1:length(gone)) {#
	         	#cat("test1",propSimNNd[gone[k]],"\n")#
	            propSimNNd[gone[k]] = findObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
	            #cat("test2",propSimNNd[gone[k]],"\n")#
      	      propIndSimNNd[gone[k]] = findWhichObsNNDist_CGW(t(as.matrix(propSimX[gone[k],])),as.matrix(propSimX[-gone[k],]),l,u)#
      	      #cat("test3",propIndSimNNd[gone[k]],"\n")#
	         }#
	      }#
      	propSimdrad = simdrad#
	    propSimdrad[draw2] = Drad[as.matrix(w[avail[draw1],])]#
		propSimDistRadMeasure[1] <- mean(propSimdrad)#
		propSimDistRadMeasure[2] <- sd(propSimdrad) #
		propSimDistRadMeasure[3:9] <- quantile(propSimdrad,seq(0.125,0.875,length=7))#
      	propSimdaxi = simdaxi#
	    propSimdaxi[draw2] = Daxi[as.matrix(w[avail[draw1],])]#
		propSimDistAxiMeasure[1] <- mean(propSimdaxi)#
		propSimDistAxiMeasure[2] <- sd(propSimdaxi) #
		propSimDistAxiMeasure[3:9] <- quantile(propSimdaxi,seq(0.125,0.875,length=7))#
#
		propSimNNdMeasure[1] <- mean(propSimNNd)#
		propSimNNdMeasure[2] <- sd(propSimNNd) #
		propSimNNdMeasure[3:9] <- quantile(propSimNNd,seq(0.125,0.875,length=7))#
		propE = sum((c(oDistRadMeasure[1:numMeasures],oDistAxiMeasure[1:numMeasures],oNNdMeasure[1:numMeasures])-c(propSimDistRadMeasure[1:numMeasures],propSimDistAxiMeasure[1:numMeasures],propSimNNdMeasure[1:numMeasures]))^2)#
		if (propE < E) { # no probability of non-acceptance#
            	cat(propE,"\n")#
			E <- propE  #
			simDistRadMeasure <- propSimDistRadMeasure # this is the new accepted simulated distance function mean#
			simDistAxiMeasure <- propSimDistAxiMeasure # this is the new accepted simulated distance function mean#
			simNNdMeasure <- propSimNNdMeasure # this is the new accepted simulated mean distances mean#
			simX <- propSimX # this is the new accepted simulated point pattern#
			temp = ptsIndex[draw2]#
            	ptsIndex[draw2] = avail[draw1]#
            	avail[draw1] = temp#
            	simdrad = propSimdrad#
            	simdaxi = propSimdaxi#
            	simNNd = propSimNNd#
			indSimNNd = propIndSimNNd#
		}#
	}#
	if(1){#
		sim_convgdE[j] <- E#
		write(t(simX),file=paste(path,path3,"simPP",j,".txt",sep=""),ncolumns=3,sep='\t')#
	}#
	else j=j-1#
}#
#t2 <- proc.time()#
#print(t2-t1)#
#write out the list of final E values for the each of the converged patterns#
write(sim_convgdE,file=paste(path,path3,"sim_convgdE",".txt",sep=""),ncolumns=1,sep='\t')#
for (j in 1:numPatterns) {#
   P=read.table(paste(path,path3,"simPP",j,".txt",sep=""),header=F)#
   block = apply( P,1,function(z){all((l_block<=z)&(z<=u_block))} )#
   P_block = P[block,]#
   write(t(P_block),file=paste(path,path3,"simPP_block",j,".txt",sep=""),ncolumns=3,sep='\t')#
}
